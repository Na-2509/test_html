//기존 방식
// function Hello(n) {
//     if (n == '1')  alert("안녕하세요") ;
//     else alert('반갑습니다.')

//     console.log('콘솔출력입니다.');
// }


// 기본함수말고 다른 화살표 함수 아래 const(상수) 화살표함수 
// 화살표함수 =>
const Hello = (n) => {
   
     if (n == '1')  alert("안녕하세요") ;
     else alert('반갑습니다.')

     console.log('콘솔출력입니다.');

// (n) 함수가 변수에 할당된 형태
// 콜백함수 : 
// 변수(Hello) 익명함수일때 () 이렇게
// 자바스크립트에서만 n === '1' 
// === 타입까지 구분하겠다는 의미 > 타입스크립트
// == 2개까지는 타입구분 없이 적용가능
// 비교연산자 ==, === 을 비교

}

const CheckVar = () => {
    // x = 10;

    // 변수 선언 안해도 자바스크립크 코드보고 알아서 적용해줌 
    // 변수가 선언이 일어나면 위로 올려두는 개념
    // var x ; 변수선언 안쓸거다.
    // 대신 let x ;로 쓸거다. 선언한게 숨겨져 있는데 let을 만나면 풀리는것
    // let만나기 전까지는 쓸수 없는것
    // 따라서 위에 x = 10; 막아줘야 let x ; 쓸 수 있다. 
    // 변수는 let 상수는 const 둘만 당분간 쓸 것 / 호이스팅
    let x ; 
    x = 'test' ;
    
    const y = '20' ;
    // y = 40;
    // consolo.log('x =' + x) ;

    // consolo.log('x =' + x) ; 써도 되지만, 아래로 써도 됨 파이썬의 F스트링과 동일
    console.log(`x = ${typeof(x)}, y = ${typeof(y)}`);
    console.log(`문자열 ${x}은 문자인가요? ${isNaN(x)?'예':'아니오'}`);
    console.log(`문자열 ${y}은 문자인가요? ${isNaN(y)?'예':'아니오'}`);

}




